<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Idle + LipSync + Blink</title>
  <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
</head>

<body style="margin:0; overflow:hidden">

<!-- UI -->
<button id="playBtn"
  style="position:fixed;bottom:20px;left:20px;
  padding:12px 18px;font-size:16px;z-index:10">
▶ Play
</button>

<a-scene>
  <a-assets>
    <audio id="voice" src="voice.mp3" preload="auto"></audio>
  </a-assets>

  <a-entity id="avatar"
    gltf-model="avatar.glb"
    position="0 0 -2"
    scale="1 1 1"
    animation-mixer="clip: Idle; loop: repeat"
    talk-system>
  </a-entity>

  <a-light type="ambient" intensity="1"></a-light>
  <a-light type="directional" position="1 2 1"></a-light>
  <a-camera position="0 1.6 0"></a-camera>
</a-scene>

<script>
AFRAME.registerComponent('talk-system', {
  init() {
    const audio = document.querySelector('#voice');
    const btn = document.querySelector('#playBtn');

    // Audio context
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const src = ctx.createMediaElementSource(audio);
    const analyser = ctx.createAnalyser();
    analyser.fftSize = 2048;
    src.connect(analyser);
    analyser.connect(ctx.destination);
    const data = new Uint8Array(analyser.frequencyBinCount);

    let mesh, dict, infl;
    this.el.addEventListener('model-loaded', () => {
      this.el.getObject3D('mesh').traverse(n => {
        if (n.morphTargetDictionary) {
          mesh = n;
          dict = n.morphTargetDictionary;
          infl = n.morphTargetInfluences;
        }
      });
    });

    const V = n => dict && dict[n] !== undefined ? dict[n] : -1;
    const smooth = (i,v)=>{ if(i>=0) infl[i]=infl[i]*0.6+v*0.4 };
    const clamp = v => Math.max(0,Math.min(1,v));

    // Idle control
    const stopIdle = () => {
      const m = this.el.components['animation-mixer'];
      if (m && m.mixer) m.mixer.stopAllAction();
    };
    const playIdle = () => {
      const m = this.el.components['animation-mixer'];
      if (m) m.playAction('Idle');
    };

    // Blink (нүд анивч)
    let blinkTime = 0;
    const blink = () => {
      const i = V('eyeBlinkLeft');
      const j = V('eyeBlinkRight');
      if (i>=0) infl[i] = 1;
      if (j>=0) infl[j] = 1;
      setTimeout(()=>{
        if (i>=0) infl[i] = 0;
        if (j>=0) infl[j] = 0;
      }, 120);
      blinkTime = Math.random()*4000 + 2000;
    };
    setTimeout(blink, 2000);

    // Lip-sync loop
    const animate = () => {
      analyser.getByteFrequencyData(data);

      let low=0, mid=0;
      for(let i=0;i<300;i++) low+=data[i];
      for(let i=300;i<1200;i++) mid+=data[i];
      low/=300*255; mid/=900*255;

      // reset visemes
      ['viseme_aa','viseme_E','viseme_I','viseme_O','viseme_U','mouthOpen']
        .forEach(v=>{ const i=V(v); if(i>=0) infl[i]=0 });

      smooth(V('viseme_aa'), clamp(low*2.2));
      smooth(V('viseme_O'),  clamp(low*1.8));
      smooth(V('viseme_E'),  clamp(mid*1.6));
      smooth(V('viseme_I'),  clamp(mid*1.4));
      smooth(V('viseme_U'),  clamp(low*1.2));
      smooth(V('mouthOpen'),clamp(low*2.4));

      requestAnimationFrame(animate);
    };

    // Button logic
    let playing = false;
    btn.onclick = async () => {
      await ctx.resume();
      if (!playing) {
        audio.play();
        stopIdle();
        animate();
        btn.innerText = "⏸ Pause";
      } else {
        audio.pause();
        playIdle();
        btn.innerText = "▶ Play";
      }
      playing = !playing;
    };

    audio.addEventListener('ended', () => {
      playIdle();
      btn.innerText = "▶ Play";
      playing = false;
    });

    // Blink loop
    setInterval(blink, () => blinkTime);
  }
});
</script>

</body>
</html>
